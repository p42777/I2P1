#include <stdio.h>

/*
Fibonacci Number : 
f(0) = 0 , f(1) = 1 (initial)
f(2) = f(0) + f(1) = 0 + 1 = 1
f(3) = f(1) + f(2) = 1 + 1 = 2
f(4) = f(2) + f(3) = 1 + 2 = 3
f(5) = f(3) + f(4) = 2 + 3 = 5
0, 1, 1, 2, 3, 5, 8, 13, 21...
*/

int fib(int i){
    if(i == 0){
        return 0;
    }
    if( i == 1 || i == 2 ){
         return 1;
    }
    else{
        return fib(i-1) + fib(i-2);
    }
}

int main(void){
    int n;
    scanf("%d", &n);
    // 顯然我們算了好多重複的東西[f(n-2)]，此算法隨著 n 成長，計算量是呈指數翻倍的，很容易就有 stack overflow 的問題(像n = 100)，但迴圈版在這裡卻不會有重複的問題。
    printf("Fibonacci(%d) : %d\n", n, fib(n));
    return 0;
}

/*
遞迴(Recursion)總整理：

1.特色
遞迴可以想像成一個塔，只要有人呼叫了function ，那就再堆一層積木上去，接著我們就暫時放下下面的東西，優先處理上面的，當一個 function 到了 return，也就是結束了，那這層的積木就會消失，我們回到下面繼續處理剛剛位完成的工作。
而迴圈就是按照你規劃 index 的變化來決定執行的方向，通常是一路向前不回頭。

2.記憶體
如同遞迴的特色，每一次呼叫就多了一個積木，但是我們等下結束了新的積木還是要去找舊的積木，所以很顯然的舊的一些資料我們必須保留，因此每次呼叫，程式會找一快空的記憶體，等到這層 function return 之後，程式會釋放這塊記憶體，之後才能被再次利用。
這種先放進去後處理、後放先處理的資料結構叫做 Stack 。
至於一個程式能要到多少記憶體，這部分是由作業系統 (OS) 決定的，當你遞回過程要求的記憶體超過了限制，意思就是你的塔疊太高了，那會產生 stack overflow，通常會這樣是因為停止條件不足或錯誤，導致你的遞回停不下來產生的。而這種錯誤在編譯其間是無法偵測到的，因此這種錯誤發生在執行期間，被歸類為 Runtime Error 。
通常 Runtime Error 的兩大原因是遞迴停不下來，或是讀到不該讀的記憶體位置 ( 像是a[-1] )

3.Tail Recursion
有一種遞迴因為比較特殊，因此我們把它歸類為 tail recursion 。這類最大的特徵就是在呼叫自己之後就結束了，也就是在呼叫之後就 return (像是Example 1)。那為什麼這樣特殊呢? 因為這類的遞迴我們呼叫時堆了一個新的積木上去，但是我們會發現，舊的積木沒有用了啊，該做的事情都做完了!!
所以我們呼叫的時候，就可以把舊的丟掉，這樣記憶體就不會隨著呼叫的次數跟著增加了。等等，那這樣跟迴圈不是一樣的意思，在同一個地方一直做差不多的事情。沒錯，所以這類遞迴大部分都可以寫成迴圈的版本，就像上面的 Example 1。
但是我就是想寫遞迴R? 那事情就更簡單了，因為這件事情其實不用我們煩惱。C語言在編譯的時候有很多選項，其中有一個是優化，有分四個等級，我們在編譯的時候如果加上 -O2 (等級二)，那如果編譯器發現了你的遞迴可以優化，那它就自動變成跟迴圈一樣的了。當然些微的差異是迴圈是用同一塊記憶體，優化過的遞迴還是會去拿新的，但是舊的會立刻釋放，因此兩著需要的記憶體是差不多的。

*/